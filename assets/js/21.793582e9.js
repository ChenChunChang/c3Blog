(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{347:function(t,v,_){"use strict";_.r(v);var a=_(3),e=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),v("p",[t._v("本文转载自《labuladong 的算法小抄》，文末会抛出链接。目的是在记录的过程中一遍学习，一遍加深印象。\n在摘录的过程中会进行适用于我本人的一些修改，需要看原版的可以点击文末的传送门。")]),t._v(" "),v("h2",{attrs:{id:"数据结构的存储方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据结构的存储方式"}},[t._v("#")]),t._v(" 数据结构的存储方式")]),t._v(" "),v("p",[v("strong",[t._v("数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）")])]),t._v(" "),v("p",[t._v("这句话怎么理解，不是还有散列表、栈、队列、堆、树、图等等各种数据结构吗？")]),t._v(" "),v("p",[t._v("我们分析问题，一定要有递归的思想，自顶向下，从抽象到具体。你上来就列出这么多，那些都属于"),v("code",[t._v("上层建筑")]),t._v("，而数组和链表才是"),v("code",[t._v("结构基础")]),t._v("。因为那样多样化\n的数据结构，究其源头，都是在链表或者数组上的特殊操作，API不同而已。")]),t._v(" "),v("p",[t._v("比如说"),v("code",[t._v("队列")]),t._v("、"),v("code",[t._v("栈")]),t._v("这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的内\n存空间存储节点指针。")]),t._v(" "),v("p",[v("code",[t._v("图")]),t._v("的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很浪费空\n间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵")]),t._v(" "),v("blockquote",[v("p",[t._v("未完待续")])])])}),[],!1,null,null,null);v.default=e.exports}}]);